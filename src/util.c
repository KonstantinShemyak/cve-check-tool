/*
 * util.c - cve-check-tool
 *
 * Copyright (C) 2015 Intel Corporation
 *
 * cve-check-tool is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 */

#define _GNU_SOURCE
#include <glib.h>
#include <gio/gio.h>
#include <stdlib.h>
#include <stdio.h>

#include "util.h"
#include "cve-check-tool.h"

#include "eopkg.h"
#include "rpm.h"

void find_sources(const char *directory, package_match_func match)
{
        autofree(GFile) *root = NULL;
        GFileInfo *info = NULL;
        autofree(GFileEnumerator) *enu = NULL;
        const gchar* name = NULL;
        GFileType type;

        root = g_file_new_for_path(directory);

        enu = g_file_enumerate_children(root, G_FILE_ATTRIBUTE_STANDARD_NAME "," G_FILE_ATTRIBUTE_STANDARD_TYPE, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS, NULL, NULL);
        if (!enu) {
                return;
        }
        while ((info = g_file_enumerator_next_file(enu, NULL, NULL)) != NULL) {
                autofree(gchar) *tpath = NULL;
                type = g_file_info_get_file_type(info);
                name = g_file_info_get_name(info);
                tpath = g_build_path(G_DIR_SEPARATOR_S, directory, g_file_info_get_name(info), NULL);
                if (!tpath) {
                        abort();
                }

                switch (type) {
                case G_FILE_TYPE_DIRECTORY:
                        find_sources(tpath, match);
                        break;
                case G_FILE_TYPE_REGULAR:
                        if (match(name)) {
                                cve_add_package((const char*)tpath);
                        }
                        break;
                default:
                        /* bail */
                        break;
                }
                g_object_unref(info);
        }
        root = NULL;
}

PackageType guess_package_type(gchar *path, bool recurse)
{
        autofree(GFileEnumerator) *enu = NULL;
        autofree(GFile) *root = NULL;
        GFileInfo *info = NULL;
        PackageType type = PACKAGE_TYPE_UNKNOWN;

        if (g_file_test(path, G_FILE_TEST_IS_DIR) && recurse) {
                root = g_file_new_for_path(path);
                enu = g_file_enumerate_children(root, G_FILE_ATTRIBUTE_STANDARD_NAME "," G_FILE_ATTRIBUTE_STANDARD_TYPE, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS, NULL, NULL);
                if (!enu) {
                        return PACKAGE_TYPE_UNKNOWN;
                }
                while ((info = g_file_enumerator_next_file(enu, NULL, NULL)) != NULL) {
                        autofree(gchar) *tpath = NULL;
                        if (g_file_info_get_file_type(info) != G_FILE_TYPE_REGULAR) {
                                goto end;
                        }
                        tpath = g_build_path(G_DIR_SEPARATOR_S, path, g_file_info_get_name(info), NULL);

                        if (rpm_is_package(tpath)) {
                                type = PACKAGE_TYPE_RPM;
                                g_object_unref(info);
                                break;
                        } else if (eopkg_is_package(tpath)) {
                                type = PACKAGE_TYPE_EOPKG;
                                g_object_unref(info);
                                break;
                        }
end:
                        g_object_unref(info);
                }
                return type;
        } else {
                if (eopkg_is_package(path)) {
                        return PACKAGE_TYPE_EOPKG;
                } else if (rpm_is_package(path)) {
                        return PACKAGE_TYPE_RPM;
                }
        }
        return PACKAGE_TYPE_UNKNOWN;
}

bool is_package_list(char *path)
{
        return g_str_has_suffix((gchar*)path, "packages") &&
                g_file_test((gchar*)path, G_FILE_TEST_IS_REGULAR);
}


gchar *demacro(GHashTable *macros, gchar *str)
{
        gchar *key = NULL, *value = NULL;

        if (!macros) {
                return str;
        }

        while (true) {
                bool hit = false;
                GHashTableIter iter;
                g_hash_table_iter_init(&iter, macros);
                while (g_hash_table_iter_next(&iter, (void**)&key, (void**)&value)) {
                        if (str_contains(str, key)) {
                                hit = true;
                                str = str_replace(str, key, value);
                        }
                }
                if (!hit) {
                        break;
                }
        }
        return str;
}

int64_t parse_xml_date(const char *date)
{
        autofree(cve_string) *tmp = cve_string_dup(date);
        autofree(GTimeZone) *tz = NULL;
        autofree(GDateTime) *t = NULL, *t2 = NULL;
        char *c = NULL;
        int64_t ret = -1;

        /* Example XML string:
         * 2015-03-05T08:24:10.220-05:00
         */
        if (!tmp) {
                return -1;
        }
        if (!(c = memchr(tmp->str, 'T', tmp->len))) {
                return -1;
        }
        if (!(c = memchr(c, '-', tmp->len - (tmp->str -c)))) {
                return -1;
        }
        gint y, m, d, h, min, s;
        if (sscanf(date, "%4d-%2d-%2dT%2d:%2d:%2d", &y, &m, &d,
                &h, &min, &s) != 6) {
                return -1;
        }
        tz = g_time_zone_new(c);
        if (!tz) {
                return -1;
        }

        t = g_date_time_new(tz, y, m, d, h, min, (gdouble)s);
        if (!t) {
                return -1;
        }
        t2 = g_date_time_to_local(t);

        ret = (int64_t)g_date_time_to_unix(t2);

        return ret;
}

bool load_cve_mapping(const char *path, char **product, char **vendor)
{
        autofree(GFile) *fi = NULL;
        autofree(GFileInputStream) *fis = NULL;
        autofree(GDataInputStream) *dis = NULL;
        gsize size;
        gchar *line = NULL;
        gchar *kproduct = NULL;
        gchar *kvendor = NULL;

        fi = g_file_new_for_path(path);
        if (!fi) {
                return false;
        }
        fis = g_file_read(fi, NULL, NULL);
        if (!fis) {
                return false;
        }
        dis = g_data_input_stream_new(G_INPUT_STREAM(fis));

        while ((line = g_data_input_stream_read_line(dis, &size, NULL, NULL))) {
                char *c = NULL;
                char *val = NULL;
                line = g_strstrip(line);

                if (g_str_equal(line, "")) {
                        goto clean;
                }
                if (!(c = memchr(line, '=', size))) {
                        goto clean;
                }
                val = c+1;
                line[(c-line)] = '\0';

                line = g_strstrip(line);
                val = g_strstrip(val);

                if (g_str_equal(line, "vendor")) {
                        kvendor = g_strdup(val);
                } else if (g_str_equal(line, "product")) {
                        kproduct = g_strdup(val);
                }

clean:
                g_free(line);
        }

        if (kvendor && kproduct && product && vendor) {
                *vendor = kvendor;
                *product = kproduct;
                return true;
        }

        if (kvendor) {
                g_free(kvendor);
        }
        if (kproduct) {
                g_free(kproduct);
        }
        return false;
}

gchar *get_absolute_path(const char *path)
{
        autofree(GFile) *file = NULL;

        file = g_file_new_for_path(path);
        if (!file) {
                return NULL;
        }
        return g_file_get_path(file);
}
