/*
 * main.c - cve-check-tool
 *
 * Copyright (C) 2015 Intel Corporation
 *
 * cve-check-tool is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 */

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <stdint.h>
#include <glib.h>
#include <gio/gio.h>
#include <libxml/xmlreader.h>
#include <curl/curl.h>
#include <sys/stat.h>

#include "cve-check-tool.h"

#include "eopkg.h"
#include "rpm.h"
#include "util.h"
#include "html.h"
#include "cli.h"
#include "csv.h"
#include "plugins/jira/jira.h"
#include "config.h"
#include "cve-string.h"

#define YEAR_START 2002
#define URI_PREFIX "http://static.nvd.nist.gov/feeds/xml/cve"
#include "fetch.h"

static CveCheckTool *self;
static char *srpm_dir = NULL;


/** XML traversal state */
static bool in_list = false;
static bool in_entry = false;
static bool in_product = false;
static bool in_summary = false;

#define DEFAULT_CONFIG_FILE     DEFAULT_PATH    "/cve-check-tool.conf"
#define SITE_CONFIG_FILE        SITE_PATH       "/cve-check-tool.conf"

/**
 * Helper utility to free a struct source_package_t
 */
static inline void package_free(void *p)
{
        if (!p) {
                return;
        }
        struct source_package_t *t = p;
        if (t->issues) { /* bless you */
                g_list_free_full(t->issues, xmlFree);
        }
        if (t->patched) {
                g_list_free_full(t->patched, xmlFree);
        }
        if (t->path) {
                g_free(t->path);
        }
        if (t->xml) {
                xmlFree((xmlChar*)t->name);
                xmlFree((xmlChar*)t->version);
        } else {
                g_free((gchar*)t->name);
                g_free((gchar*)t->version);
        }
        if (t->extra && srpm_dir) {
                g_strfreev(t->extra);
        }

        free(t);
}

/**
 * Purse a CPE line into a consumable form
 *
 * @param inp cpe:/ identifier string
 * @param vuln Where to store the resulting vulnerability data
 * @return a boolean value, true if the operation succeeded
 */
static bool parse_vuln(const xmlChar* inp, struct vulnerability_t *vuln)
{
        gchar *product = NULL;
        gchar *vendor = NULL;
        gchar *version = NULL;
        int len = 0;
        /* Example: cpe:/a:oracle:siebel_crm:8.1.1 */
        gchar **splits = g_strsplit((const gchar*)inp, ":", 10);
        if ((len = g_strv_length(splits)) < 4) {
                g_strfreev(splits);
                return false;
        }

        vendor = g_strdup(splits[2]);
        product = g_strdup(splits[3]);
        if (len > 4) {
                version = g_strdup(splits[4]);
        }
        g_strfreev(splits);

        vuln->vendor = vendor;
        vuln->product = product;
        vuln->version = version;

        return true;
}

/**
 * More state tracking
 */
static xmlChar *cur_id = NULL;
static xmlChar *summary = NULL;
static xmlChar *score = NULL;
static xmlChar *modified = NULL;
static bool had_interest = false;

static bool in_link = false;
static GList *uris = NULL;
static bool in_vuln_cvss = false;
static bool in_base_metrics = false;
static bool in_score = false;
static bool in_date = false;

/**
 * Main iterator for XML parsing
 *
 * @param r A valid xmlTextReaderPtr (open)
 */
static void process_node(xmlTextReaderPtr r)
{
        const xmlChar *name = NULL;
        const xmlChar *value = NULL;
        struct vulnerability_t vuln = { 0 };
        struct source_package_t *t = NULL;
        xmlChar *uri = NULL;
        int64_t last_mod = -1;

        name = xmlTextReaderConstName(r);
        if (!name) {
                return;
        }
        /* New entry */
        if (xmlStrEqual(name, BAD_CAST "entry")) {
                in_entry = !in_entry;
                if (!in_entry) {
                        if (had_interest) {
                                struct cve_entry_t *ent = NULL;

                                ent = calloc(1, sizeof(struct cve_entry_t));
                                gchar *tmpk = NULL, *tmpv = NULL;
                                tmpk = g_strdup((const gchar*)cur_id);
                                tmpv = g_strdup((const gchar*)summary);
                                /* Force overwrite/free correctly */
                                if (g_hash_table_contains(self->cdb, tmpk)) {
                                        g_hash_table_remove(self->cdb, tmpk);
                                }
                                ent->id = tmpk;
                                ent->summary = tmpv;
                                ent->uris = uris;
                                if (self->modified > 0) {
                                        last_mod = parse_xml_date((char*)modified);
                                        ent->modified = last_mod;
                                }
                                if (score) {
                                        ent->score = g_strdup((gchar*)score);
                                }
                                g_hash_table_insert(self->cdb, tmpk, ent);
                                uris = NULL;
                        } else {
                                if (uris) {
                                        g_list_free_full(uris, xmlFree);
                                        uris = NULL;
                                }
                        }
                        if (score) {
                                xmlFree(score);
                                score = NULL;
                        }
                        if (cur_id) {
                                xmlFree(cur_id);
                                cur_id = NULL;
                        }
                        if (summary) {
                                xmlFree(summary);
                                summary = NULL;
                        }
                        if (modified) {
                                xmlFree(modified);
                                modified = NULL;
                        }
                        had_interest = false;
                        return;
                }
                if (cur_id) {
                        xmlFree(cur_id);
                }
                cur_id  = xmlTextReaderGetAttribute(r, BAD_CAST "id");
                if (!cur_id) {
                        return;
                }
                return;
        }
        if (xmlStrEqual(name, BAD_CAST "vuln:references")) {
                in_link = !in_link;
                return;
        }
        if (in_link && xmlStrEqual(name, BAD_CAST "vuln:reference")) {
                uri = xmlTextReaderGetAttribute(r, BAD_CAST "href");
                if (!uri) {
                        return;
                }
                uris = g_list_append(uris, uri);
                uri = NULL;
        }
        if (xmlStrEqual(name, BAD_CAST "vuln:vulnerable-software-list")) {
                in_list = !in_list;
                return;
        }
        if (in_list && xmlStrEqual(name, BAD_CAST "vuln:product")) {
                in_product = !in_product;
                return;
        }
        /* Score checking */
        if (xmlStrEqual(name, BAD_CAST "vuln:cvss")) {
                in_vuln_cvss = !in_vuln_cvss;
                return;
        }
        if (in_vuln_cvss && xmlStrEqual(name, BAD_CAST "cvss:base_metrics")) {
                in_base_metrics = !in_base_metrics;
                return;
        }
        if (in_base_metrics && xmlStrEqual(name, BAD_CAST "cvss:score")) {
                in_score = !in_score;
        }
        if (in_base_metrics && in_score) {
                value = xmlTextReaderConstValue(r);
                if (!value) {
                        return;
                }
                score = xmlStrdup(value);
        }
        /* Get last modified */
        if (xmlStrEqual(name, BAD_CAST "vuln:last-modified-datetime")) {
                in_date = !in_date;
        }
        if (in_date && self->modified > 0) {
                value = xmlTextReaderConstValue(r);
                if (!value) {
                        return;
                }
                modified = xmlStrdup(value);
        }
        /* Product checking */
        if (in_list && in_product) {
                value = xmlTextReaderConstValue(r);
                if (!value) {
                        return;
                }
                if (!parse_vuln(value, &vuln)) {
                        return;
                }
                t = g_hash_table_lookup(self->db, vuln.product);
                if (!t) {
                        goto clean;
                }
                if (!(vuln.version && xmlStrEqual(t->version, BAD_CAST vuln.version))) {
                        goto clean;
                }

                if (self->is_patched && self->is_patched(t, (gchar*)cur_id)) {
                        if (!g_list_find_custom(t->patched, cur_id, (GCompareFunc)strcmp)) {
                                gchar *tmp = g_strdup((const gchar*)cur_id);
                                if (!tmp) {
                                        abort();
                                }
                                t->patched = g_list_append(t->patched, tmp);
                                had_interest = true;
                        }
                } else {
                        if (!g_list_find_custom(t->issues, cur_id, (GCompareFunc)strcmp)) {
                                gchar *tmp = g_strdup((const gchar*)cur_id);
                                if (!tmp) {
                                        abort();
                                }
                                t->issues = g_list_append(t->issues, tmp);
                                had_interest = true;
                        }
                }
clean:
                g_free(vuln.vendor);
                g_free(vuln.product);
                if (vuln.version) {
                        g_free(vuln.version);
                }
                return;
        }
        if (in_entry && xmlStrEqual(name, BAD_CAST "vuln:summary")) {
                in_summary = !in_summary;
                if (in_summary && summary) {
                        xmlFree(summary);
                        summary = NULL;
                }
                return;
        }
        if (in_summary) {
                summary = xmlTextReaderValue(r);
                return;
        }
}

/**
 * Parse an NVD xml database
 *
 * @param fname Path to the nvd db
 * @return a boolean value, true if the operation succeeded
 */
static bool parse_file(const char *fname)
{
        xmlTextReaderPtr r = xmlReaderForFile(fname, NULL, 0);
        if (!r) {
            return false;
        }
        int ret;

        while ((ret = xmlTextReaderRead(r)) > 0) {
                process_node(r);
        }
        xmlFreeTextReader(r);

        return true;
}

/**
 * Util to free a struct cve_entry_t
 */
static inline void cve_free(void *v)
{
        if (!v) {
                return;
        }
        struct cve_entry_t *t = v;
        if (t->uris) {
                g_list_free_full(t->uris, xmlFree);
        }
        if (t->score) {
                xmlFree((xmlChar*)t->score);
        }
        g_free(t->id);
        g_free(t->summary);
        g_free(t);
}

void cve_add_package(const char *path)
{
        struct source_package_t *pkg = self->examine(path);
        if (!pkg) {
                return;
        }
        g_hash_table_insert(self->db, pkg->name, pkg);
}

static void show_version(void)
{
        const gchar *msg = "\
" PACKAGE " " PACKAGE_VERSION "\n\
Copyright (C) 2015 Intel Corporation\n\
" PACKAGE_NAME " is free software; you can redistribute it and/or modify\n\
it under the terms of the GNU General Public License as published by\n\
the Free Software Foundation; either version 2 of the License, or\n\
(at your option) any later version.";
        printf("%s\n", msg);
}

static bool hide_patched = false;
static bool show_unaffected = false;
static bool _show_version = false;
static bool skip_update = false;
static gchar *forced_type = NULL;
static bool no_html = false;
static bool csv_mode = false;
static char *modified_stamp = NULL;
static bool auto_bug = false;
static gchar *auto_bug_template = NULL;

static GOptionEntry _entries[] = {
        { "not-patched", 'n', 0, G_OPTION_ARG_NONE, &hide_patched, "Hide patched/addressed CVEs", NULL },
        { "not-affected", 'a', 0, G_OPTION_ARG_NONE, &show_unaffected, "Show unaffected items", NULL },
        { "skip-update", 'u', 0, G_OPTION_ARG_NONE, &skip_update, "Skip update of databases", NULL },
        { "version", 'v', 0, G_OPTION_ARG_NONE, &_show_version, "Show version", NULL },
        { "type", 't', 0, G_OPTION_ARG_STRING, &forced_type, "Set package type to T", "T" },
        { "no-html", 'N', 0, G_OPTION_ARG_NONE, &no_html, "Disable HTML report", NULL },
        { "modified", 'm', 0, G_OPTION_ARG_STRING, &modified_stamp, "Ignore reports after modification date", "D" },
        { "srpm-dir", 's', 0, G_OPTION_ARG_STRING, &srpm_dir, "Source RPM directory", "S" },
        { "csv", 'c', 0, G_OPTION_ARG_NONE, &csv_mode, "Output CSV formatted data only", NULL },
        { "auto-bug", 'b', 0, G_OPTION_ARG_NONE, &auto_bug, "Enable automatic bug tracking", NULL },
        { "auto-bug-template", 'j', 0, G_OPTION_ARG_STRING, &auto_bug_template, "Path to optional auto-bug json template file", NULL },
        { NULL }
};

static bool set_package_type(PackageType type)
{
        switch (type) {
                case PACKAGE_TYPE_EOPKG:
                        self->examine = &eopkg_inspect_pspec;
                        self->is_patched = &eopkg_is_patched;
                        self->locate = &eopkg_locate_sources;
                        return true;
                case PACKAGE_TYPE_RPM:
                        self->examine = &rpm_inspect_spec;
                        self->is_patched = &rpm_is_patched;
                        self->locate = &rpm_locate_sources;
                        return true;
                default:
                        return false;
        }
}

/**
 * Helper utility to free the bug struct
 */
static inline void bug_free(void *p)
{
   struct jira_issue_t *t = p;
    if (!t) {
        return;
    }
    g_free(t->key);
    g_free(t->summary);
    g_free(t->description);
    g_free(t->status);
    g_slice_free(struct jira_issue_t, t);
}

/**
 * Here is where the bug tracker plugin is called.
 */

bool track_bugs(const gchar *auto_bug_template)
{
        GList *cves, *cve = NULL;
        GHashTable *jira_issues  = NULL;
        autofree(gchar) *jira_search_json = NULL;
        autofree(gchar) *jira_add_json = NULL;
        autofree(gchar) *cve_url = NULL;
        struct cve_entry_t *cve_entry = NULL;
        bool ret = true;
        self->bdb = NULL;

        if (self == NULL || self->cdb == NULL) {
                return false;
        }
        if (!g_hash_table_size(self->cdb)) {
                return false;
        }
        if (!init_jira_plugin(self->config, NULL)) {
                return false;
        }
        if (!is_jira_alive()) {
                return false;
        }
        if (!build_search_jira_issues(&jira_search_json)) {
                return false;
        }
        if (!get_jira_issues(jira_search_json, &jira_issues)) {
                return false;
        }
        cves = g_hash_table_get_values(self->cdb);
        for (cve=cves; cve; cve=cve->next) {
                cve_entry = cve->data;
                if (!g_hash_table_contains(jira_issues,cve_entry->id)) {
                        cve_url = g_strdup_printf("https://cve.mitre.org/cgi-bin/cvename.cgi?name=%s", cve_entry->id);
                        printf("Adding to bug database: %s\n -%s\n",
                        cve_entry->id, cve_url);
                        if (auto_bug_template == NULL) {
                                ret = build_new_jira_issue(
                                cve_entry->id, cve_url, false, &jira_add_json);
                        } else {
                                ret = build_new_jira_issue_file(
                                cve_entry->id, cve_url,
                                auto_bug_template, &jira_add_json);
                        }
                        if (!ret) {
                                break;
                        }
                        ret = add_new_jira_issue(jira_add_json);
                        if (!ret) {
                                break;
                        }
                }
        }
        g_list_free(cves);
        free_jira_issues(&jira_issues);
        if (!ret) {
                printf("Error: Aborting adding CVEs to bug database due to errors\n");
        }
        if (ret) {
                ret = get_jira_issues(jira_search_json, &jira_issues);
                if (ret) {
                        self->bdb = jira_issues;
                } else {
                        free_jira_issues(&jira_issues);
                }
        }
        destroy_jira_plugin();
        return ret;
}

/**
 * Main entry.
 */
int main(int argc, char **argv)
{
        autofree(GError) *error = NULL;
        autofree(GOptionContext) *context = NULL;
        autofree(GDateTime) *date = NULL;
        autofree(gchar) *target = NULL;
        autofree(GKeyFile) *config = NULL;
        autofree(cve_string) *workdir = NULL;
        __attribute__ ((unused)) struct stat st;
        gint year;
        int ret = EXIT_FAILURE;
        PackageType type;
        CveCheckTool instance = {0};
        instance.modified = -1;
        time_t ti;
        LIBXML_TEST_VERSION

        self = &instance;
        context = g_option_context_new(" - cve check tool");
        g_option_context_add_main_entries(context, _entries, NULL);
        if (!g_option_context_parse(context, &argc, &argv, &error)) {
                g_printerr("Invalid options: %s\n", error->message);
                goto cleanup;
        }

        if (_show_version) {
                show_version();
                ret = EXIT_SUCCESS;
                goto cleanup;
        }

        if (argc != 2) {
                printf("Usage: %s [path-to-source-spec|path-to-source-list-file]\n", argv[0]);
                goto cleanup;
        }

        if (!g_file_test(argv[1], G_FILE_TEST_EXISTS)) {
                printf("%s does not exist\n", argv[1]);
                goto cleanup;
        }

        target = get_absolute_path(argv[1]);
        if (!target) {
                goto cleanup;
        }

        if (srpm_dir) {
                if (!g_file_test(srpm_dir, G_FILE_TEST_IS_DIR)) {
                        printf("srpm directory does not exist or is not a directory\n");
                        goto cleanup;
                }
                self->is_patched = srpm_is_patched;
        }

        if (forced_type) {
                if (g_str_equal(forced_type, "rpm")) {
                        type = PACKAGE_TYPE_RPM;
                } else if (g_str_equal(forced_type, "eopkg")) {
                        type = PACKAGE_TYPE_EOPKG;
                } else {
                        printf("Unknown type: \"%s\".\nCurrently supported types: eopkg, rpm", forced_type);
                        goto cleanup;
                }
        } else {
                type = guess_package_type(target, false);
        }

        if (modified_stamp) {
                ti = curl_getdate(modified_stamp, NULL);
                if (ti <= 0) {
                        fprintf(stderr, "Invalid date\n");
                        goto cleanup;
                }
                instance.modified = (int64_t)ti;
        }

        config = g_key_file_new();
        if (g_file_test(SITE_CONFIG_FILE, G_FILE_TEST_EXISTS)) {
                if (!g_key_file_load_from_file(config, SITE_CONFIG_FILE, G_KEY_FILE_KEEP_TRANSLATIONS, &error)) {
                        fprintf(stderr, "Unable to read configuration: %s\n", error->message);
                        goto cleanup;
                }
        } else if (g_file_test(DEFAULT_CONFIG_FILE, G_FILE_TEST_EXISTS)) {
                if (!g_key_file_load_from_file(config, DEFAULT_CONFIG_FILE, G_KEY_FILE_KEEP_TRANSLATIONS, &error)) {
                        fprintf(stderr, "Unable to read default configuration: %s\n", error->message);
                        goto cleanup;
                }
        } else {
                fprintf(stderr, "No valid configuration found, aborting\n");
                goto cleanup;
        }

        self->config = config;
        self->hide_patched = hide_patched;
        self->show_unaffected = show_unaffected;
        instance.db = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, package_free);
        instance.cdb = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, cve_free);
        instance.bdb = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, bug_free);

        /* Automatically disable HTML output in CSV mode */
        if (csv_mode) {
                no_html = true;
        }

        workdir = cve_string_dup_printf("%s/NVDS/", g_get_home_dir());
        if (stat(workdir->str, &st) != 0) {
                if (mkdir(workdir->str, 0777) != 0) {
                        fprintf(stderr, "Unable to create required directory: %s\n", workdir->str);
                        goto cleanup;
                }
        }

        if (type > PACKAGE_TYPE_MIN && type < PACKAGE_TYPE_UNKNOWN) {
                if (!set_package_type(type)) {
                        printf("Unsupported package type\n");
                        goto cleanup;
                }
                /* Attempt to add a single package.. */
                if (g_file_test(target, G_FILE_TEST_IS_DIR)) {
                        /* Recurse.. */
                        self->locate(target);
                } else {
                        cve_add_package(target);
                }
        } else if (type == PACKAGE_TYPE_UNKNOWN && is_package_list(target)) {
                /* We're a packages thingy. */
                autofree(GFile) *fi = NULL;
                autofree(GFile) *basedir = NULL;
                autofree(gchar) *basedirsz = NULL;
                autofree(GFileInputStream) *fis = NULL;
                autofree(GDataInputStream) *dis = NULL;
                char *read = NULL;

                fi = g_file_new_for_path(target);
                basedir = g_file_get_parent(fi);
                basedirsz =  g_file_get_path(basedir);;
                fis = g_file_read(fi, NULL, &error);

                if (!fis) {
                        g_printerr("Unable to open file for reading: %s\n", error->message);
                        goto cleanup;
                }
                dis = g_data_input_stream_new(G_INPUT_STREAM(fis));

                while ((read = g_data_input_stream_read_line(dis, NULL, NULL, NULL)) != NULL) {
                        /* Attempt to get */
                        autofree(gchar) *path = NULL;

                        read = g_strchomp(read);
                        if (g_str_equal(read, "")) {
                                continue;
                        }

                        /* Tab delimited files mean we don't look through git trees */
                        if (str_contains(read, "\t")) {
                                autofree(gstrv) *splits = g_strsplit(read, "\t", 3);
                                struct source_package_t *t = NULL;

                                if (srpm_dir) {
                                        t = rpm_inspect_srpm(srpm_dir, splits[0], splits[1], splits[2]);
                                        if (!t) {
                                                goto clean;
                                        }
                                } else {
                                        t = calloc(1, sizeof(struct source_package_t));
                                        if (!t) {
                                                goto clean;
                                        }
                                        t->path = NULL;
                                        t->name = g_strdup(splits[0]);
                                        t->version = g_strdup(splits[1]);
                                }
                                g_hash_table_insert(self->db, t->name, t);
                                goto clean;
                        }

                        /* try directory above *first* as this is the norm */
                        path = g_build_path(G_DIR_SEPARATOR_S, basedirsz, "..", read, NULL);
                        if (!g_file_test(path, G_FILE_TEST_EXISTS)) {
                                g_free(path);
                                /* Fall back to building from current directory */
                                path = g_build_path(G_DIR_SEPARATOR_S, basedirsz, read, NULL);
                        }

                        if (!g_file_test(path, G_FILE_TEST_EXISTS)) {
                                printf("Warning: Not found: %s\n", path);
                                goto clean;
                        }

                        /* Attempt to determine type.. */
                        if (type == PACKAGE_TYPE_UNKNOWN) {
                                type = guess_package_type(path, true);
                                if (type == PACKAGE_TYPE_UNKNOWN) {
                                        printf("Unable to determine package type, bailing\n");
                                        g_free(read);
                                        goto cleanup;
                                }
                                if (!set_package_type(type)) {
                                        printf("Unsupported package type\n");
                                        g_free(read);
                                        goto cleanup;
                                }
                        }
                        self->locate(path);
clean:
                        g_free(read);
                }
        } else {
                printf("Unsupported file: %s\n", target);
                goto cleanup;
        }

        gint size = g_hash_table_size(self->db);
        if (size == 0) {
                printf("No source files were encountered, aborting\n");
                goto cleanup;
        }
        /* Consider a verbosity flag... */
        if (!csv_mode) {
                printf("Scanned %d source file%s\n", size, size > 1 ? "s" : "");
        }
        date = g_date_time_new_now_local();
        year = g_date_time_get_year(date);

        /* Round 1: Obtain and extract updated DBs */
        if (!skip_update) {
                for (int i = YEAR_START; i <= year+1; i++) {
                        autofree(gchar) *uri = NULL;
                        autofree(gchar) *target = NULL;
                        FetchStatus st;

                        if (i > year) {
                                uri = g_strdup_printf("%s/nvdcve-2.0-Modified.xml.gz", URI_PREFIX);
                                target = g_strdup_printf("%s/NVDS/nvdcve-2.0-Modified.xml.gz", g_get_home_dir());
                        } else {
                                uri = g_strdup_printf("%s/nvdcve-2.0-%d.xml.gz", URI_PREFIX, i);
                                target = g_strdup_printf("%s/NVDS/nvdcve-2.0-%d.xml.gz", g_get_home_dir(), i);
                        }

                        st = fetch_uri(uri, target, !csv_mode);
                        switch (st) {
                                case FETCH_STATUS_FAIL:
                                        fprintf(stderr, "Failed to fetch %s\n", uri);
                                        goto cleanup;
                                case FETCH_STATUS_UPDATE:
                                        if (!gunzip_file(target)) {
                                                fprintf(stderr, "Unable to extract %s\n", target);
                                                goto cleanup;
                                        }
                                        break;
                                default:
                                        break;
                        }
                }
        }

        for (int i = YEAR_START; i <= year+1; i++) {
                autofree(gchar) *s = NULL;
                if (i > year) {
                        s = g_strdup_printf("%s/NVDS/nvdcve-2.0-Modified.xml", g_get_home_dir());
                } else {
                        s = g_strdup_printf("%s/NVDS/nvdcve-2.0-%d.xml", g_get_home_dir(), i);
                }
                if (!parse_file(s)) {
                        fprintf(stderr, "\nUnable to find: %s\n", s);
                        goto cleanup;
                }
                autofree(gchar) *txt =  g_strdup_printf("Loaded: %s", basename(s));
                if (csv_mode) {
                        continue;
                }
                printf("\r%-40s", txt);
                fflush(stdout);

                if (i > year) {
                        printf("\n");
                }
        }

        if (auto_bug) {
                track_bugs(auto_bug_template);
        }

        if (csv_mode) {
                csv_write_report(self);
        } else {
                cli_write_report(self);
        }

        if (!no_html) {
                if (!write_report(self, "report.html")) {
                        fprintf(stderr, "Report generation failed\n");
                } else {
                        ret = EXIT_SUCCESS;
                }
        } else {
                ret = EXIT_SUCCESS;
        }

cleanup:
        if (instance.db) {
                g_hash_table_unref(instance.db);
        }
        if (self->cdb) {
                g_hash_table_unref(instance.cdb);
        }
        xmlCleanupParser();
        return ret;
}
