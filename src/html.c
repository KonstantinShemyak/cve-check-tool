/*
 * html.c - cve-check-tool helpers
 *
 * Copyright (C) 2015 Intel Corporation
 *
 * cve-check-tool is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 */

#define _GNU_SOURCE

#include "config.h"
#include "util.h"
#include "template.h"
#include "cve-check-tool.h"

#define TMPL(X) DATA_DIRECTORY G_DIR_SEPARATOR_S X ".template"

#define TMPL_BOTTOM             TMPL("bottom")
#define TMPL_PACKAGE            TMPL("package")
#define TMPL_TOP                TMPL("top")

#define NVD_CVE_URI "http://web.nvd.nist.gov/view/vuln/detail?vulnId="

static inline gchar *_concat(gchar *source, gchar *moar)
{
        gchar *ret = g_strconcat(source, moar, NULL);
        if (ret) {
                g_free(source);
                return ret;
        }
        return source;
}

static inline gchar *dotemplate(GHashTable *k, char *p)
{
        gchar *ret = template_string(p, k);
        g_free(p);
        return ret;
}

static inline bool load_template(const char *tmpl_name, gchar **ret)
{
        autofree(GError) *error = NULL;

        if (!g_file_get_contents(tmpl_name, ret, NULL, &error)) {
                g_printerr("Unable to access mandatory template: %s\n", tmpl_name);
                *ret = NULL;
                return false;
        }
        return true;
}

static inline gchar *vector_map(gchar *vector)
{
        if (!vector) {
                return "";
        }
        if (g_str_equal(vector, ACCESS_VECTOR_ADJACENT)) {
                return "Adjacent Network";
        } else if (g_str_equal(vector, ACCESS_VECTOR_LOCAL)) {
                return "Local";
        } else if (g_str_equal(vector, ACCESS_VECTOR_NETWORK)) {
                return "Remote (Network)";
        } else {
                return vector;
        }
}

/**
 * Textual representation of bug status
 */
static inline gchar *status_map(ReportStatus status)
{
        switch (status) {
        case REPORT_STATUS_OPEN:
                return "Open";
        case REPORT_STATUS_CLOSED:
                return "Closed";
        default:
                return "Unreported";
        }
}

#define LOAD_TEMPLATE(name,ret) if (!load_template(name,ret)) { return false; }

bool write_report(CveCheckTool *self,  char *filename)
{
        autofree(gchar) *bottom, *package, *top;
        autofree(GError) *error = NULL;
        bottom = package = top = NULL;
        autofree(GHashTable) *macros = NULL;
        autofree(gchar) *aff = NULL;
        autofree(gchar) *output = NULL;
        autofree(gchar) *body = NULL;
        GHashTableIter iter;
        gchar *key = NULL;
        struct source_package_t *v = NULL;
        GList *c = NULL;
        struct cve_entry_t *c_entry = NULL;
        gint affected = 0;
        guint row = 0;

        /* Mandatory template files */
        LOAD_TEMPLATE(TMPL_BOTTOM, &bottom);
        LOAD_TEMPLATE(TMPL_PACKAGE, &package);
        LOAD_TEMPLATE(TMPL_TOP, &top);

        macros = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, NULL);
        g_hash_table_insert(macros, "LNVD_CVE_URI", NVD_CVE_URI);
        if (self->bugs) {
                /* When we switch to TemplateContext we'll use real booleans */
                g_hash_table_insert(macros, "bugs_enabled", "true");
        }
        g_hash_table_iter_init(&iter, self->db);
        while (g_hash_table_iter_next(&iter, (void**)&key, (void**)&v)) {
                bool hit = false;
                if (!v->issues && !v->patched && !self->show_unaffected) {
                        continue;
                }
                if (!v->issues && self->hide_patched) {
                        continue;
                }

                guint cve_len = 0;

                if (v->issues) {
                        cve_len += g_list_length(v->issues);
                }
                if (v->patched && !self->hide_patched) {
                        cve_len += g_list_length(v->patched);
                }

                g_hash_table_insert(macros, "PACKAGE_NAME", key);

                /* TODO: Collapse redundancy into helper. */
                g_hash_table_insert(macros, "STATUS_CLASS", "not-patched");
                g_hash_table_insert(macros, "STATUS_STRING", "Check");
                for (c = v->issues; c; c = c->next) {
                        autofree(gchar) *ent = NULL;
                        c_entry = g_hash_table_lookup(self->cdb, (gchar*)c->data);

                        if (self->modified > 0 && c_entry->modified > self->modified) {
                                continue;
                        }
                        hit = true;

                        g_hash_table_insert(macros, "LCVEID", c_entry->id);
                        g_hash_table_insert(macros, "CVEID", c_entry->id);
                        g_hash_table_insert(macros, "DESC", c_entry->summary);
                        g_hash_table_insert(macros, "ROW_CLASS", row % 2 ? "even" : "odd");
                        g_hash_table_insert(macros, "SCORE", c_entry->score);
                        g_hash_table_insert(macros, "VECTOR", vector_map(c_entry->vector));
                        /* TODO: Emit URI */
                        g_hash_table_insert(macros, "REPORT_STATUS", status_map(c_entry->status));

                        /* TODO: Add links .. */
                        ent = g_strdup(package);
                        ent = dotemplate(macros, ent);
                        if (body) {
                                body = _concat(body, ent);
                        } else {
                                body = g_strdup(ent);
                        }
                        ++row;
                }
                g_hash_table_insert(macros, "STATUS_CLASS", "patched");
                g_hash_table_insert(macros, "STATUS_STRING", "Patched");
                if (!self->hide_patched && v->patched) {
                        for (c = v->patched; c; c = c->next) {
                                autofree(gchar) *ent = NULL;
                                c_entry = g_hash_table_lookup(self->cdb, (gchar*)c->data);

                                if (self->modified > 0 && c_entry->modified > self->modified) {
                                        continue;
                                }
                                hit = true;

                                g_hash_table_insert(macros, "LCVEID", c_entry->id);
                                g_hash_table_insert(macros, "CVEID", c_entry->id);
                                g_hash_table_insert(macros, "DESC", c_entry->summary);
                                g_hash_table_insert(macros, "ROW_CLASS", row % 2 ? "even" : "odd");
                                g_hash_table_insert(macros, "SCORE", c_entry->score);
                                g_hash_table_insert(macros, "VECTOR", vector_map(c_entry->vector));
                                /* TODO: Emit URI */
                                g_hash_table_insert(macros, "REPORT_STATUS", status_map(c_entry->status));
                                /* TODO: Add links .. */
                                ent = g_strdup(package);
                                ent = dotemplate(macros, ent);
                                if (body) {
                                        body = _concat(body, ent);
                                } else {
                                        body = g_strdup(ent);
                                }
                                ++row;
                        }
                }
                if (hit) {
                        ++affected;
                }
        }

        aff = g_strdup_printf("CVE Report for %d package%s", affected,
                affected > 1 ? "s" : "");

        g_hash_table_insert(macros, "AFFECTED_STRING", aff);
        top = dotemplate(macros, top);
        output = g_strdup(top);
        output = _concat(output, body);
        output = _concat(output, bottom);
        /* Write file */
        if (!g_file_set_contents(filename, output, -1, &error)) {
                g_printerr("Unable to write report: %s\n", error->message);
                return false;
        }

        return true;
}
