/*
 * plugin-manager.c
 *
 * Copyright (C) 2015 Intel Corporation
 *
 * cve-check-tool is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 */

#include "config.h"

#include <stdbool.h>
#include "plugin.h"
#include "util.h"
#include "dlfcn.h"
#include "plugin-manager.h"


static GHashTable *_plugins;

static void load_module(const char *name)
{
        void *handle, *cast;
        gchar *path = NULL;
        char *error = NULL;
        cve_plugin_init init_func;
        CvePlugin *plugin = NULL;

        path = g_build_filename(MODULE_DIR, name, NULL);
        if (!path) {
                fprintf(stderr, "No memory\n");
                return;
        }
        handle = dlopen(path, RTLD_LAZY);
        if (!handle) {
                fprintf(stderr, "Unable to load module: %s\n", dlerror());
                return;
        }
        dlerror();
        cast = dlsym(handle, "cve_plugin_module_init");
        if (!cast || (error = dlerror()) != NULL) {
                fprintf(stderr, "Cannot load module: %s\n", error);
                abort();
        }
        dlerror();
        memcpy(&init_func, &cast, sizeof(init_func));

        plugin = calloc(1, sizeof(struct CvePlugin));
        if (!plugin) {
                fprintf(stderr, "Unable to allocate memory\n");
                abort();
        }
        if (!init_func(plugin)) {
                fprintf(stderr, "Plugin initialisation failed\n");
                abort();
        }
        if (!plugin->name) {
                fprintf(stderr, "Plugin %s does not set a name - aborting\n", name);
                abort();
        }
        plugin->handle = handle;
        g_hash_table_insert(_plugins, (char*)plugin->name, plugin);
}

static void destroy_plugin(CvePlugin *plugin)
{
        if (plugin->destroy) {
                plugin->destroy(plugin);
        }
        if (plugin->handle) {
                dlclose(plugin->handle);
        }
        free(plugin);
}

void cve_plugin_manager_init()
{
        GDir *dir = NULL;
        autofree(GError) *error = NULL;
        const gchar *fpath = NULL;

        if (_plugins) {
                return;
        }
        _plugins = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, (GDestroyNotify)destroy_plugin);

        dir = g_dir_open(MODULE_DIR, 0, NULL);
        if (!dir) {
                fprintf(stderr, "Unable to list modules: %s\n", error->message);
                return;
        }

        while ((fpath = g_dir_read_name(dir))) {
                if (g_str_has_suffix(fpath, ".so")) {
                        load_module(fpath);
                }
        }
        g_dir_close(dir);
}

void cve_plugin_manager_destroy()
{
        if (!_plugins) {
                return;
        }
        g_hash_table_unref(_plugins);
        _plugins = NULL;
}


CvePlugin *cve_plugin_get_by_name(const char *name)
{
        CvePlugin *ret = NULL;

        if (!_plugins) {
                return NULL;
        }
        ret = g_hash_table_lookup(_plugins, name);
        return ret;
}
