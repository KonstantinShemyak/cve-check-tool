/*
 * update.c - cve-check-tool
 *
 * Copyright (C) 2015 Intel Corporation
 *
 * cve-check-tool is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 */

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <stdint.h>
#include <glib.h>
#include <gio/gio.h>
#include <curl/curl.h>
#include <sys/stat.h>

#include "cve-check-tool.h"

#include "util.h"
#include "config.h"
#include "cve-string.h"
#include "core.h"

#define YEAR_START 2002
#define URI_PREFIX "http://static.nvd.nist.gov/feeds/xml/cve"
#include "fetch.h"

static void show_version(void)
{
        const gchar *msg = "\
" PACKAGE " " PACKAGE_VERSION "\n\
Copyright (C) 2015 Intel Corporation\n\
" PACKAGE_NAME " is free software; you can redistribute it and/or modify\n\
it under the terms of the GNU General Public License as published by\n\
the Free Software Foundation; either version 2 of the License, or\n\
(at your option) any later version.";
        fprintf(stderr, "%s\n", msg);
}

static bool _show_version = false;
static bool _quiet = false;

static GOptionEntry _entries[] = {
        { "version", 'v', 0, G_OPTION_ARG_NONE, &_show_version, "Show version", NULL },
        { "quiet", 'q', 0, G_OPTION_ARG_NONE, &_quiet, "Run silently", NULL },
        { NULL }
};

static gchar *get_db_path(void)
{
        return g_build_path(G_DIR_SEPARATOR_S, g_get_home_dir(), "NVDS", "nvd.db", NULL);
}

/**
 * TODO: Remove these symbol issues by further refactoring
 */
void cve_add_package(__attribute__ ((unused)) const char *path)
{
}

/**
 * Main entry.
 */
int main(int argc, char **argv)
{
        autofree(GError) *error = NULL;
        autofree(GOptionContext) *context = NULL;
        autofree(gchar) *db_path = NULL;
        autofree(cve_string) *workdir = NULL;
        autofree(CveDB) *cve_db = NULL;
        __attribute__ ((unused)) struct stat st;
        autofree(GDateTime) *date = NULL;
        int year;
        int ret = EXIT_FAILURE;
        bool db_exist = false;

        LIBXML_TEST_VERSION
        context = g_option_context_new(" - cve update");
        g_option_context_add_main_entries(context, _entries, NULL);
        if (!g_option_context_parse(context, &argc, &argv, &error)) {
                g_printerr("Invalid options: %s\n", error->message);
                goto end;
        }

        if (_show_version) {
                show_version();
                ret = EXIT_SUCCESS;
                goto end;
        }

        db_path = get_db_path();
        if (!db_path) {
                fprintf(stderr, "main(): Out of memory\n");
                goto end;
        }

        db_exist = cve_file_exists(db_path);

        workdir = cve_string_dup_printf("%s/NVDS/", g_get_home_dir());
        if (stat(workdir->str, &st) != 0) {
                if (mkdir(workdir->str, 0777) != 0) {
                        fprintf(stderr, "Unable to create required directory: %s\n", workdir->str);
                        goto end;
                }
        }

        cve_db = cve_db_new(db_path);
        if (!cve_db) {
                fprintf(stderr, "main(): DB initialisation issue\n");
                goto end;
        }

        date = g_date_time_new_now_local();
        year = g_date_time_get_year(date);

        for (int i = YEAR_START; i <= year+1; i++) {
                autofree(gchar) *uri = NULL;
                autofree(gchar) *target = NULL;
                FetchStatus st;
                bool update = false;

                if (i > year) {
                        uri = g_strdup_printf("%s/nvdcve-2.0-Modified.xml.gz", URI_PREFIX);
                        target = g_strdup_printf("%s/NVDS/nvdcve-2.0-Modified.xml.gz", g_get_home_dir());
                } else {
                        uri = g_strdup_printf("%s/nvdcve-2.0-%d.xml.gz", URI_PREFIX, i);
                        target = g_strdup_printf("%s/NVDS/nvdcve-2.0-%d.xml.gz", g_get_home_dir(), i);
                }

                st = fetch_uri(uri, target, !_quiet);
                switch (st) {
                        case FETCH_STATUS_FAIL:
                                fprintf(stderr, "Failed to fetch %s\n", uri);
                                goto end;
                        case FETCH_STATUS_UPDATE:
                                update = true;
                                break;
                        default:
                                if (!_quiet) {
                                        fprintf(stderr, "Skipping: %s\n", basename(target));
                                }
                                break;
                }
                if (update || !db_exist) {
                        /* Only load on updates */
                        if (!gunzip_file(target)) {
                                fprintf(stderr, "Unable to extract %s\n", target);
                                goto end;
                        }
                        if (!cve_db_load(cve_db, target)) {
                                fprintf(stderr, "\nUnable to find: %s\n", target);
                                goto end;
                        }
                        if (!_quiet) {
                                fprintf(stderr, "Loaded: %s\n", basename(target));
                        }
                }
        }

end:
        xmlCleanupParser();
        return ret;
}
