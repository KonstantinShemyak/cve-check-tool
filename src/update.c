/*
 * update.c - cve-check-tool
 *
 * Copyright (C) 2015 Intel Corporation
 *
 * cve-check-tool is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 */

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <stdint.h>
#include <glib.h>
#include <gio/gio.h>
#include <curl/curl.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <signal.h>

#include "cve-check-tool.h"

#include "util.h"
#include "config.h"
#include "cve-string.h"
#include "core.h"

#include "update.h"

#define YEAR_START 2002
#define URI_PREFIX "http://static.nvd.nist.gov/feeds/xml/cve"
#include "fetch.h"

static bool do_unlock(void);

static gchar *get_db_path(void)
{
        return g_build_path(G_DIR_SEPARATOR_S, g_get_home_dir(), "NVDS", "nvd.db", NULL);
}

gchar *get_lock_file(void)
{
        return g_build_path(G_DIR_SEPARATOR_S, g_get_home_dir(), "NVDS", "nvd.lock", NULL);
}

#define UPDATE_THRESHOLD 7200
/* Wait at most 5 minutes for a parallel client */
#define UPDATE_WAIT 300

static bool reg = false;
static volatile int lock_fd = -1;

bool update_required()
{
        time_t t;

        autofree(gchar) *db = get_db_path();
        struct stat st = {.st_ino = 0};
        if (stat(db, &st) != 0) {
                return true;
        }

        t = time(NULL);
        if (difftime(t, st.st_mtime) >= UPDATE_THRESHOLD) {
                return true;
        }

        return false;
}

static void exit_unlock(void)
{
        if (lock_fd > 0 && !do_unlock()) {
                fprintf(stderr, "exit_unlock(): Failed to unlock cleanly\n");
        }
}

static void exit_unlock_sig(__attribute__ ((unused)) int sig)
{
        exit_unlock();
        exit(sig);
}

static bool do_lock(gchar *path)
{
        int fd = 0;
        int res = 0;
        struct flock lock = { 0 };


        if ((fd = open(path, O_WRONLY|O_CREAT|O_NONBLOCK, S_IRUSR|S_IWUSR)) < 0) {
                return false;
        }

        lock.l_type = F_WRLCK;
        if ((res = fcntl(fd, F_SETLK, &lock)) < 0) {
                close(fd);
                /* File existence is enough */
                fprintf(stderr, "do_lock(): Failed to gain exclusive lock: %s\n", strerror(errno));
                return false;
        }
        if (!reg) {
                reg = true;
                signal(SIGINT, exit_unlock_sig);
                atexit(exit_unlock);
        }

        lock_fd = fd;
        return true;
}


static bool do_unlock()
{
        struct flock lock = { 0 };
        autofree(gchar) *lfile = NULL;
        bool ret = true;

        if (lock_fd < 0) {
                return false;
        }

        /* Release it */
        lock.l_type = F_UNLCK;
        if (fcntl(lock_fd, F_SETLK, &lock) < 0) {
                close(lock_fd);
                fprintf(stderr, "do_unlock(): Unable to unlock file: %s\n", strerror(errno));
                ret = false;
        }

        close(lock_fd);
        lock_fd = -1;

        lfile = get_lock_file();
        if (!lfile) {
                fprintf(stderr, "do_unlock(): Out of memory\n");
                ret = false;
        } else {
                if (unlink(lfile) != 0) {
                        fprintf(stderr, "do_unlock(): Lockfile not removed, will cause issues.");
                        ret = false;
                }
        }


        return ret;
}

static bool wait_file(gchar *path, int timeout)
{
        int elapsed = 0;

        fprintf(stderr, "Waiting for another instance of cve-check-tool to finish updating\n");

        while (true) {
                if (!cve_file_exists(path)) {
                        return true;
                }
                if (elapsed >= timeout) {
                        return false;
                }
                /* Sure, it's fuzzy, but we don't need that kind of granularity */
                sleep(1);
                elapsed += 1;
        }
}

bool update_db(bool quiet)
{
        autofree(gchar) *db_path = NULL;
        autofree(cve_string) *workdir = NULL;
        autofree(CveDB) *cve_db = NULL;
        __attribute__ ((unused)) struct stat st;
        autofree(GDateTime) *date = NULL;
        autofree(gchar) *lock_file = NULL;
        int year;
        bool ret = false;
        bool db_exist = false;

        db_path = get_db_path();
        if (!db_path) {
                fprintf(stderr, "update_db(): Out of memory\n");
                goto end;
        }

        lock_file = get_lock_file();
        if (!lock_file) {
                fprintf(stderr, "update_db(): Out of memory\n");
                goto end;
        }

        if (cve_file_exists(lock_file)) {
                if (!wait_file(lock_file, UPDATE_WAIT)) {
                        fprintf(stderr, "update_db(): Waited too long for parallel update\n");
                        goto end;
                }
                if (!update_required()) {
                        return true;
                }
        }

        /* Go and lock now. */
        if (!do_lock(lock_file)) {
                fprintf(stderr, "update_db(): Cannot get lock file\n");
                return false;
        }

        db_exist = cve_file_exists(db_path);

        workdir = cve_string_dup_printf("%s/NVDS/", g_get_home_dir());
        if (stat(workdir->str, &st) != 0) {
                if (mkdir(workdir->str, 0777) != 0) {
                        fprintf(stderr, "Unable to create required directory: %s\n", workdir->str);
                        goto end;
                }
        }

        cve_db = cve_db_new(db_path);
        if (!cve_db) {
                fprintf(stderr, "main(): DB initialisation issue\n");
                goto end;
        }

        date = g_date_time_new_now_local();
        year = g_date_time_get_year(date);

        for (int i = YEAR_START; i <= year+1; i++) {
                autofree(gchar) *uri = NULL;
                autofree(gchar) *target = NULL;
                FetchStatus st;
                bool update = false;

                if (i > year) {
                        uri = g_strdup_printf("%s/nvdcve-2.0-Modified.xml.gz", URI_PREFIX);
                        target = g_strdup_printf("%s/NVDS/nvdcve-2.0-Modified.xml.gz", g_get_home_dir());
                } else {
                        uri = g_strdup_printf("%s/nvdcve-2.0-%d.xml.gz", URI_PREFIX, i);
                        target = g_strdup_printf("%s/NVDS/nvdcve-2.0-%d.xml.gz", g_get_home_dir(), i);
                }

                st = fetch_uri(uri, target, !quiet);
                switch (st) {
                        case FETCH_STATUS_FAIL:
                                fprintf(stderr, "Failed to fetch %s\n", uri);
                                goto end;
                        case FETCH_STATUS_UPDATE:
                                update = true;
                                break;
                        default:
                                if (!quiet) {
                                        fprintf(stderr, "Skipping: %s\n", basename(target));
                                }
                                break;
                }
                if (update || !db_exist) {
                        /* Only load on updates */
                        if (!gunzip_file(target)) {
                                fprintf(stderr, "Unable to extract %s\n", target);
                                goto end;
                        }
                        if (!cve_db_load(cve_db, target)) {
                                fprintf(stderr, "\nUnable to find: %s\n", target);
                                goto end;
                        }
                        if (!quiet) {
                                fprintf(stderr, "Loaded: %s\n", basename(target));
                        }
                }
        }

        ret = true;

end:
        do_unlock();

        return ret;
}

/*
 * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
 *
 * Local variables:
 * c-basic-offset: 8
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 *
 * vi: set shiftwidth=8 tabstop=8 expandtab:
 * :indentSize=8:tabSize=8:noTabs=true:
 */
