/*
 * template.c - cve-check-tool
 *
 * Copyright (C) 2015 Intel Corporation
 *
 * cve-check-tool is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 */

#define _GNU_SOURCE

#include "template.h"
#include "util.h"


#include <string.h>

struct TemplateContext {
        gchar *name;
        struct TemplateContext *parent;
        GHashTable *values;
        GHashTable *sects;
        gchar *sect_key;
        bool emit;
};

TemplateContext *template_context_new()
{
        TemplateContext *ret = NULL;

        ret = calloc(1, sizeof(struct TemplateContext));
        memset(ret, 0, sizeof(struct TemplateContext));
        ret->values = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, (GDestroyNotify)cve_string_free);
        ret->sects = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, NULL);
        ret->name = NULL;
        ret->emit = true;
        return ret;
}


void template_context_free(TemplateContext *self)
{
        if (!self) {
                return;
        }
        if (self->name) {
                g_free(self->name);
        }
        if (self->values) {
                g_hash_table_unref(self->values);
        }
        if (self->sects) {
                g_hash_table_unref(self->sects);
        }
        if (self->sect_key) {
                g_free(self->sect_key);
        }
        free(self);
}

bool template_context_add(TemplateContext *ctx, const char *key, char *val)
{
        if (!ctx) {
                return false;
        }
        g_hash_table_insert(ctx->values, g_strdup(key), cve_string_dup(val));
        return false;
}

void template_context_add_subcontext(TemplateContext *ctx, const char *key, TemplateContext *child)
{
        if (!ctx || !child) {
                return;
        }
        if (g_hash_table_contains(ctx->sects, key)) {
                return;
        }
        child->parent = ctx;
        child->name = g_strdup(key);
        g_hash_table_insert(ctx->sects, child->name, child);
}

static inline TemplateContext* get_context(TemplateContext *ctx, const char *key)
{
        return ctx && ctx->sects && key ? g_hash_table_lookup(ctx->sects, key) : NULL;
}

char *template_context_process_line(TemplateContext *self, const char *original)
{
        char *c = NULL, *s = NULL;
        int offset = 0;
        TemplateContext *ctx = self;
        cve_string *ret_string = NULL;

        if (!ctx || !ctx->values) {
                /* Always return allocated string for consistency */
                return strdup((char*) original);
        }
        if (!original) {
                return NULL;
        }

        cve_string *input = cve_string_dup(original);
        if (!input) {
                return NULL;
        }


        while ((c = memchr(input->str+offset, '{', input->len-offset))) {
                autofree(cve_string) *newstr = NULL;
                autofree(cve_string) *left = NULL;
                cve_string *val = NULL;

                int oldoffset = offset;
                offset = (c - input->str);


                if (ctx->emit && offset-oldoffset >= 1) {
                        char *strstart = input->str+oldoffset;
                        strstart[offset-oldoffset] = '\0';

                        if (!ret_string) {
                                ret_string = cve_string_dup(strstart);
                        } else {
                                cve_string_cat(ret_string, strstart);
                        }
                }

                if (*(c+1) != '{') {
                        if (!ret_string) {
                                ret_string = cve_string_dup("{");
                        } else {
                                cve_string_cat(ret_string, "{");
                        }
                        ++offset;
                        goto bail;
                }
                s = c;
                c = memchr(c, '}', input->len);
                if (!c) {
                        if (!ret_string) {
                                ret_string = cve_string_dup("{");
                        } else {
                                cve_string_cat(ret_string, "{");
                        }
                        ++offset;
                        goto bail;
                }
                if (*(c+1) != '}') {
                        if (!ret_string) {
                                ret_string = cve_string_dup("{");
                        } else {
                                cve_string_cat(ret_string, "{");
                        }
                        ++offset;
                        goto bail;
                }

                int start =  (s-input->str);
                start+=2;
                int end =  (c-input->str);
                int length = end - start;

                newstr = cve_string_dup(input->str+start);
                newstr->str[length] = '\0';
                newstr->len = length;

                offset += length + 4;
                if (newstr->str[0] == '#') {
                        TemplateContext *child = get_context(ctx, newstr->str+1);
                        ctx->sect_key = g_strdup(newstr->str+1);
                        if (!child) {
                                ctx->emit = false;
                        } else {
                                ctx = child;
                                ctx->emit = true;
                        }
                } else if (newstr->str[0] == '/') {
                        gchar *sect = newstr->str+1;
                        if (ctx->name && g_str_equal(sect, ctx->name)) {
                                ctx = ctx->parent;
                        } else {
                                if (ctx->sect_key && !g_str_equal(ctx->sect_key, sect)) { 
                                        g_warning("Ending section without starting one: %s (ctx: %s)", sect, ctx->sect_key);
                                        return NULL;
                                }
                        }
                        if (ctx->sect_key) {
                                g_free(ctx->sect_key);
                                ctx->sect_key = NULL;
                        }
                        ctx->emit = true;
                } else {
                        if (ctx->emit) {
                                val = g_hash_table_lookup(ctx->values, newstr->str);
                                if (!val && ctx->parent) {
                                        /* Search backwards in context stack */
                                        TemplateContext *search = ctx;
                                        while ((search = search->parent)) {
                                                val = g_hash_table_lookup(search->values, newstr->str);
                                                if (val) {
                                                        break;
                                                }
                                        }
                                }
                                if (val) {
                                        if (!ret_string) {
                                                ret_string = cve_string_dup(val->str);
                                        } else {
                                                cve_string_cat(ret_string, val->str);
                                        }
                                }
                        }
                }
bail:
                if (offset >= input->len) {
                        break;
                }
        }

        if (offset < input->len) {
                if (!ret_string) {
                        ret_string = cve_string_dup(input->str+offset);
                } else {
                        cve_string_cat(ret_string, input->str+offset);
                }
        }
        if (ret_string) {
                return g_strdup(ret_string->str);
        }

        return NULL;
}

char *template_string(const char *original, GHashTable *keys)
{
        autofree(TemplateContext) *context = NULL;
        GHashTableIter iter;
        gchar *key = NULL, *value = NULL;

        if (!keys) {
                return g_strdup(original);
        }

        context = template_context_new();

        if (keys) {
                g_hash_table_iter_init(&iter, keys);
                while (g_hash_table_iter_next(&iter, (void**)&key, (void**)&value)) {
                        template_context_add(context, key, value);
                }
        }
        return template_context_process_line(context, original);
}
